---
title: [모던 리눅스 교과서 1. 리눅스 소개]
author: excelsiorKim
date: 2024-06-17 14:30:03 +0900
categories: [Book, Linux]
tags: [Linux, Modern Linux, 모던 리눅스 교과서]
keywords: [Linux, Modern Linux, 모던 리눅스 교과서]
description: 모던 리눅스 독서 기록
toc: true
toc_sticky: true
---

## 리눅스 소개
### 모던(현대적인) 환경이란 무엇인가
- **모던** : 이 책에서 '모던'이란 클라우드 컴퓨팅부터 라즈베리 파이에 이르는 모든 것을 의미할 수 있다. 
  - 최근 도커(Docker)의 부상과 함께 관련된 인프라스트럭처(Infra-Structure)의 혁신은 개발자와 인프라스트럭처 운영자의 환경을 크게 바꿨다.
- 아래와 같은 모던 환경을 보며 그 환경 속에 리눅스가 수행하는 중요한 역할을 알아본다.
  - **모바일 디바이스** : 오늘날 대다수의 전화기와 태블릿은 리눅스의 변형인 안드로이드OS를 탑재하고 있다.
    - 안드로이드 앱 개발에 관심 있다면 안드로이드 [개발자 사이트](https://oreil.ly/xf5kC)를 방문해 자세한 정보를 확인할 수 있다.
  - **클라우드 컴퓨팅** : 클라우드를 통해 모바일이나 초소형 공간과 유사한 패턴을 대규모로 확인할 수 있다.
    - 일례로 오픈소스 소프트웨어의 맥락에서 클라우드 제공업체로의 대규모 아웃소싱도 확립되어 있을 뿐 아니라, 성공적인 ARM 기반 AWS 그래비톤 제품과 같은 강력하고 안전하며 에너지를 절감하는 새로운 CPU 아키텍처도 등장했다.
  - **(스마트) 사물 인터넷** : 센서에는 드론에 이르는 IoT 관련 프로젝트와 제품들의 환경은 모바일 디바이스보다 전력 소비에 대한 요구사항이 훨씬 더 까다롭다.
    - 게다가 이러한 기기들은 예를 들어 데이터를 전송하기 위해 하루에 한 번만 깨어나는 등 항상 실행되지 않는 환경인 경우가 많다. 이러한 환경의 또 다른 중요한 측면은 실시간 기능이다.(https://oreil.ly/zBsRy)
    - IoT 환경에서 리눅스를 시작하는 데 관심이 있다면 [AWS IoT 에듀킷](https://oreil.ly/3x0uf)를 고려해보자
  - **프로세서 아키텍처의 다양성** : 데스크톱과 노트북 시스템 이후 모바일 디바이스의 등장으로 ARM 아키텍처(https://oreil.ly/sioDd) 도입은 물론, 최근에 RISC-V(https://oreil.ly/Tf0bb)의 사용도 늘어나고 있다.
    - 이와 동시에 고(Go)나 러스트(Rust)같은 다중 아키텍처 프로그래밍 언어와 도구가 점점 더 널리 보급되어 엄청난 변화를 불러 일으키고 있다.
- 이 모든 상황을 일컬어 **모던 환경** 이라 정의할 수 있다.
- 전부는 아니더라도 대부분은 리눅스에서 실행되거나 어떤 형태로든 리눅스르 사용한다.

### (지금까지의) 리눅스 이야기
- **1990년대**
  - 공개된 기록에 따르면 리눅스 프로젝트는 리눅스 토발즈가 comp.os.minix 뉴스 그룹에 보낸 메일을 기점으로 시작됐다.
  - 이 프로젝트는 Lines of Code(LOC)수와 도입률 측면에서 곧바로 궤도에 올랐다.
  - 대부분의 유닉스/GNU 소프트웨어를 실행할 수 있게 만들겠다는 초창기 목표는 그 시점에 이미 달성됐다.
  - 이후 1990년대의 최초 상용 제품이라 할 수 있는 레드햇(Red Hat) 리눅스가 등장하였다.
- **2000년부터 2010년까지**
  - 유닉스의 한계를 뛰어넘어 성장하고 있는 리눅스는 구글, 아마존, IBM같은 거대 기업이 도입을 추진하며 엄청난 성장세를 보였다.
    - 이는 배포판 전쟁(https://oreil.ly/l6X4Q)의 정점을 찍는다.
- 2010년 이후 오늘날까지
  - 리눅스는 데이터 센터와 클라우드는 물론, 모든 유형의 IoT 디바이스와 전화에서 중추적인 역할을 맡아왔다.
  - 어떤 의미에서 배포 전쟁은 끝났다고 생각할 수 있다.
  - 그리고 어떤 의미에서는 컨테이너의 급부상이 이러한 발전을 촉발 시켰다고도 볼 수 있다.
### 운영체제는 왜 필요한가
- 운영체제가 없을 경우 아래와 같은 작업을 직접 처리해야 한다(사실 이곳에 담지 못할 만큼 더 많다.)
  - 메모리 관리
  - 인터럽트 처리
  - I/O 디바이스와의 통신
  - 파일 관리
  - 네트워크 스택 구성과 관리
- 운영체제는 이처럼 모든 무거운 작업을 수행해 다양한 하드웨어 구성 요소를 추상화하고 2장에서 자세히 다룰 리눅스 커널 같은 깔끔하고 멋지게 설계된 API(애플리케이션 프로그래밍 인터페이스)를 제공한다.
- 일반적으로 OS가 공개하는 API를 일컬어 시스템 콜(system call 혹은 sys call)이라고 부른다.
- 고, 러스트, 파이썬, 자바 등의 고급 프로그래밍 언어는 이러한 시스템 콜 위에 빌드되며, 시스템 콜을 감싼(wrapping)라이브러리가 제공된다.
- 이 모든 것을 통해 리소스를 직접 관리하지 않고 비즈니스 로직에 집중할 수 있으며, 다양한 하드웨어도 관리할 수 있게 된다.

### 시스템 콜의 예시
- 현재 사용자의 ID를 반환하는 `getuid(2)`(https://oreil.ly/md15Z)는 아래와 같이 설명되어 있다.
  - 이때 (2)의 의미는 리눅스 프로그래밍 게시물에서 자세히 다룰 예정이다.
```
getuid() returns the real user ID of the calling process
```

- 이러한 `getuid` 시스템 콜은 라이브러리에서 프로그래밍 방식으로 사용할 수 있다.
- 커맨드라인(shell)상에서는 getuid 시스템 콜과 동일한 기능을 하는 id를 다음과 같이 사용한다.
```
id --user
```

### 리눅스 배포판
- 그냥 '리눅스'라고만 하면 그 의미가 명확하지 않다.
- 해당 책에서는 시스템 콜과 디바이스 드라이버의 집합을 말할 때 '리눅스 커널' 또는 그냥 '커널'이라는 용어를 사용한다.
- **리눅스 배포판**(https://oreil.ly/U9luq)(Linux distribution은 짧게 줄여 distro 라고도 부른다.)이란 커널과 관련 구성 요소의 전체 bundle(묶음)을 의미한다.
  - 이는 패키지 관리, 파일시스템 레이아웃, init system, 사용자가 미리 선택한 셸이 포함된다.
  - 이 모든 작업을 직접 수행할 수도 있다. 커널을 다운로드하고 컴파일한 후 패키지 관리자를 선태하는 등의 작업을 수행하고 직접 고유한 배포판을 생성할 수 있다.
    - 아치 리눅스(Arch Linux)가 사용자하된 리눅스 배포판을 만들기 용이하다(https://oreil.ly/UBSHM)
- 기존 배포판(우분투, 레드햇(RHEL), CentOS 등)과 모던 배포판(보틀로켓, 플랫카) 등 리눅스 배보판의 범위가 얼마나 거대한지를 느끼려면 [DistroWatch](https://oreil.ly/DWmrr)를 살펴 보면 된다.

### 리소스 가시성
- 리눅스는 유닉스의 전통을 따르고 있기에 기본적으로 리소스의 전역 보기(global view)를 지원한다.
  - 유닉스와 확장 리눅스에서 거론되는 "everything is a file"이라는 말 처럼 **리소스란** 소프트웨어 실행을 지원하는 데 사용할 수 있는 모든 것을 간주한다.
  - 여기에는 하드웨어와 그 추상화(예 : CPU, RAM 파일 등), 파일시스템, 하드 디스크 드라이브(HDD), SSD(Solid-State Drive), 프로세스, 디바이스나 라우팅 테이블 같은 네트워킹 관련 항목, 사용자를 나타내는 자격증명(credential)이 포함된다.
  - **전역 보기(global view)** : 시스템의 모든 프로세스가 동일한 전역 차원 집합(파일 시스템, 프로세스 ID 공간, 사용자 ID 공간 등)을 공유하는 전통적인 유닉스/리눅스 모델이다.
    - 이 모델에서는 프로세스 간 강력한 격리가 없어 한 프로세스가 다른 프로세스에 영향을 줄 수 있다.
  - **가상화된 보기(Virtualized View)** : 각 프로세스 또는 프로세스 그룹이 자체 격리된 자원 집합을 갖도록 한다.
    - 이는 컨테이너 기술을 통해 구현되는데, 컨테이너는 호스트 시스템과 다른 컨테이너로부터 어느 정도 격리된 환경에서 실행된다. 각 컨테이너는 자체 파일 시스템, 프로세스 트리, 네트워크 스택 등을 가질 수 있다.	
- 하지만 리눅스의 모든 것이 기본적으로 전역은 아니다.
  1. 여러 사용자나 프로세스가 병렬로 실행된다는 환상은 리소스에 대한 (제한된) 가시성에서 일부 비롯된다.
     - 리눅스에서 (특정하게 지원되는)리소스에 대한 로컬 보기를 제공하는 방법은 네임 스페이스를 통하는 것이다.
  2. 독립적인 차원이란 격리(isolation)을 뜻한다.
     - 여기서 말하는 격리에 대한 기준은 모호한 부분이 존재한다.
### POSIX
- POSIX(Portable Operating System Interface)란 유닉스 운영체제용 서비스 인터페이스를 정의하는 IEEE 표준이다.
  - 이를 통해 여러 운영체제의 구현체 사이에서 이식성을 제공해준다.
  - POSIX에 대해 자세히 알고 싶다면 [이곳](https://oreil.ly/DO04h) 논문을 확인해라.
- 리눅스는 BDS(Berkeley Software Distribution) 스타일의 시스템과는 반대로 구시대 AT&T 유닉스 시스템의 분위기를 유닉스 SVID(System V Interface Definition)와 호환될 뿐만 아니라 POSIX와도 호환된다.

### 정리
- 이 책의 '모던'이란 전화기, 퍼블릭 클라우드 제공업체의 데이터 센터, 라즈베리 파이 같은 임베디드 시스템 등 현대적인 환경에서의 리눅스 사용을 의미한다.
- 리눅스의 배경을 간단하게 요약 설명했고, 기본 하드웨어를 추상화하고 프로세스, 메모리, 파일, 네트워크 관리 같은 기본 기능들을 애플리케이션에 제공하는 일반적인 운영체제의 역할과 리눅스가 이 작업, 특히 리소스 가시성과 관련해 작업을 수행하는 방법을 알아봤다.
- 참고 서적
  - Linux Cookbook, Carla Schroder
  - Efficient Linux at the Command Line, Daniel J.Barrett
  - 리눅스 시스템 프로그래밍, Robert Love
- 온라인 자료
  - [유닉스 환경의 고급 프로그래밍](https://oreil.ly/hS0G0)
  - [유닉스의 탄생](https://oreil.ly/MlQ0J)